#Functions for Visualize RSA relatedness test from the results generated by the rsatoolbox===========================================
library(dplyr)
library(tidyr)
library(ggplot2)
library(R.matlab)
library(NCmisc)
#Helper Functions=======================================================
#flatten_balanced_list_with_names()------------------------------------------------------------
#Flatten a nested list with correspondant names. The name of dach element is derived from the
#dimension names of each layer.
#Parameter:
#-nested_balanced_list:  the nested list to flatten
#-num_layers: the number of layers to be flattened.
#Return:
#-a flatten list with named element.
flatten_balanced_list_with_names=function(nested_balanced_list,num_layers){
  #Flatten the nested list--------------------------------------
  if(num_layers==3){
    balanced_list_flatten=do.call(c, unlist(nested_balanced_list, recursive=FALSE))
  }else if (num_layers==2){
    balanced_list_flatten= unlist(nested_balanced_list, recursive=FALSE)
  }else{
    stop("Unexpected number of layers!")
  }
  
  #Assign names to the elements in the flatten list-----------------
  #Get the dimension names of each layer
  list_names_layer_dims=list()
  current_layer=nested_balanced_list
  for(layer_index in 1:num_layers){
    current_layer_names=dimnames(current_layer)[[1]]
    current_layer=current_layer[[1]]#Deepen one layer
    
    list_names_layer_dims[[layer_index]]=current_layer_names
  }
  
  #Generate the element names by combination of different layer names
  #(note that the order is retained when converting to factor)
  df_element_names=do.call(expand.grid,c(list_names_layer_dims))
  element_names=
    df_element_names%>%
    arrange_at(vars(everything()))%>%
    unite(element_name,everything())%>%
    mutate(element_name=gsub(x=element_name,pattern="\\.",replacement="_"))%>%
    pull(element_name)
  #Assign names
  names(balanced_list_flatten)=element_names
  
  return(balanced_list_flatten)
}
#Main Functions=========================================================
#RSA_relatedness_nested_mat_to_single_mats()--------------------------------------------------------
#Read in the mat file which is a structure containing multiple relatedness test results, and separate them into
# a list of single relatedness test results.
#Parameter:
#-file_collect_mat: the mat file which is a structure containing multiple relatedness test results.
#-num_layers: the number of layers to be flattened.
#Return:
#-a list of single relatedness test results.
RSA_relatedness_nested_mat_to_single_mats=function(file_collect_mats,num_layers){
  #Read in the mats file---------------------------------------
  collect_mats=readMat(file_collect_mats)[[1]]
  #Flatten the nested list into named elements
  collect_mats_flatten=flatten_balanced_list_with_names(collect_mats,num_layers)
  # #Flatten the nested list--------------------------------------
  # collect_mats_flatten=do.call(c, unlist(collect_mats, recursive=FALSE))
  # 
  # #Assign names to the elements in the flatten list-----------------
  # #Get the dimension names of each layer
  # list_names_layer_dims=list()
  # current_layer=collect_mats
  # for(layer_index in 1:num_layers){
  #   current_layer_names=dimnames(current_layer)[[1]]
  #   current_layer=current_layer[[1]]#Deepen one layer
  #   
  #   list_names_layer_dims[[layer_index]]=current_layer_names
  # }
  # 
  # #Generate the element names by combination of different layer names
  # #(note that the order is retained when converting to factor)
  # df_element_names=do.call(expand.grid,c(list_names_layer_dims))
  # element_names=
  #   df_element_names%>%
  #     arrange_at(vars(everything()))%>%
  #     unite(element_name,everything())%>%
  #     mutate(element_name=gsub(x=element_name,pattern="\\.",replacement="_"))%>%
  #     pull(element_name)
  # #Assign names
  # names(collect_mats_flatten)=element_names
  return(collect_mats_flatten)
}

#RSA_relatedness_single_mat_to_df()--------------------------------------------------------
#Take in the the single mat file which contains the relatedness test results of one test, and then convert it into a
#data frame format.
#Parameter:
#-mat: the collect_stats_p_r.mat file which contains the relatedness test result.
#fields in the mat file
# candRelatedness.r: Correlations of each candidate to the reference RDM per each subject [n_subject x n_models]
# candRelatedness.p: Corresponding uncorrected p values [1 x n_models]
# SEs: Standard errors of average RDM correlations (the error bar of each bar)  [1 x n_models]
# candDifferences.r: Matrix of bar-height differences (i.e. average RDM-correlation differences). [n_models x n_model]
# candDifferences.p: Corresponding uncorrected p values [n_models x n_model]
# orderedCandidateRDMnames: Candidate RDM names in the order in which the bars are displayed (also the order used for the return values).
# ceiling: Ceiling lower and upper bounds.
#Return:
#-df_relatedness_tidy_plot: results for the classic bar plots
# $cand_relatedness_r_avg: Averaged correlations of each candidate to the reference RDM [nrow = n_models]
# $cand_relatedness_p: Corresponding uncorrected p values [nrow = n_models]
# $cand_SEs: Standard errors of average RDM correlations (the error bar of each bar)  [nrow = n_models]
# $ceiling_lower: Ceiling lower bounds. [nrow = n_models]
# $ceiling_upper: Ceiling upper bounds. [nrow = n_models]
# $cand_RDM_names: Candidate RDM names in the order in which the bars are displayed (also the order used 
#  for the return values). [nrow = n_models]
#-df_relatedness_subjects_r: individual differences in relatedness test
# Correlations of each candidate to the reference RDM per each subject [nrow = n_models, ncol = n_subject]
#-df_cand_differences: results for between model comparison
# $cand_differences_r: Matrix of bar-height differences (i.e. average RDM-correlation differences). [nrow = n_models, ncol = n_models]
# $cand_difference_p: Corresponding uncorrected p values [nrow = n_models, ncol = n_models]
RSA_relatedness_single_mat_to_df=function(mat){
  #Assign name to each result field-----------------------------------------------------
  dim_names=dimnames(mat)[[1]]
  names(mat)=dim_names
  #Get constants-------------------------------------------------------------------------
  n_models=dim(mat$candRelatedness.r)[2]
  n_subjects=dim(mat$candRelatedness.r)[1]
  #Assign each named field to a variable (to be collected in the data frame below--------
  # lapply(1:length(mat),
  #        FUN = function(field_index){
  #          field_name=dim_names[field_index]
  #          field_value=mat[[field_index]]
  #          assign(field_name,field_value)
  # })
  #Preprocess each named field into variables-------------------------------------------------------------
  
  #Model names
  cand_RDM_names=unname(unlist(mat$orderedCandidateRDMnames))
  cand_RDM_names=gsub(cand_RDM_names,pattern = "-",replacement = "_")
  
  #The relatedness correlations per candidate model x subject 
  df_cand_relatedness_r=data.frame(t(mat$candRelatedness.r)) #[nrow = n_models, ncol = n_subject]
  names(df_cand_relatedness_r)=paste0("cand_r_",c(1:n_subjects)) #[nrow = n_models]
  cand_relatedness_p=mat$candRelatedness.p[1,] #[nrow = n_models]
  
  
  #The differences between models
  cand_differences_r=data.frame(mat$candDifferences.r) #[nrow = n_models, ncol = n_models]
  names(cand_differences_r)=paste0("diff_r_",cand_RDM_names)
  cand_differences_p=data.frame(mat$candDifferences.p) #[nrow = n_models, ncol = n_models]
  names(cand_differences_p)=paste0("diff_p_",cand_RDM_names)
  
  #Ceiling
  ceiling_lower=mat$ceiling[1,1] #[nrow = n_models]
  ceiling_upper=mat$ceiling[1,2] #[nrow = n_models]
  #SEs
  cand_SEs=mat$SEs[1,] #[nrow = n_models]
  #Threshold (FDR)
  thresh_fdr=mat$thresh.fdr[1,] #Single value
  
  ##Unused - Separate the result into different data frames
  # Collect variables into a data frame----------------------------------------------------
  # df_result=
  #   data.frame(cand_RDM_names,
  #              df_cand_relatedness_r,#[nrow = n_models, ncol = n_subject]
  #              cand_relatedness_p,#[nrow = n_models]
  #              cand_differences_r,#[nrow = n_models, ncol = n_models]
  #              cand_differences_p,#[nrow = n_models, ncol = n_models]
  #              ceiling_lower,
  #              ceiling_upper,
  #              cand_SEs)%>%
  # mutate(cand_relatedness_r_avg=rowMeans(select(.,matches("cand_r_\\d"))))
  #Return values------------------------------------------------------------------------
  
  cand_relatedness_r_avg=rowMeans(df_cand_relatedness_r)
  cand_RDM_names=factor(cand_RDM_names,levels = cand_RDM_names) #Retain the order information
  
  df_relatedness_tidy_plot=
    data.frame(cand_RDM_names,cand_relatedness_r_avg,
               cand_relatedness_p,
               cand_SEs,
               ceiling_lower,ceiling_upper,
               n_subjects,
               thresh_fdr)
  df_relatedness_subjects_r=
    data.frame(cand_RDM_names,
               df_cand_relatedness_r)
  
  df_cand_differences=
    data.frame(cand_RDM_names,
               cand_differences_r,cand_differences_p)
  
  return(list(df_relatedness_tidy_plot=df_relatedness_tidy_plot,
              df_relatedness_subjects_r=df_relatedness_subjects_r,
              df_cand_differences=df_cand_differences))
}
#RSA_relatedness_bar_plot()---------------------------------------------------------------------------
#Plot the var plot of the relatedness test
#Parameter:
#-df:the data frame which contains the information for the bar plot. 
#    It is the "df_relatedness_tidy_plot" in the result of the RSA_relatedness_single_mat_to_df()
#-as_panel: To decide whether the plot is going to be a panel inside a grid.arrage(). If true, then
#    the title and axis labels will be omit. Replace the title by the age group x VOI.
#-df_rdm_color: The data frame which defines the color of each bar.
#-noise_ceiling: Whether to show the noise ceiling or not (default as true).
#-limit_y: The limit of the y axis (default as the size of the plot).
#-remove_panel_title: Whether to shoe the title of each panel (default as false).
#-bar_order: The order of the bars (candidate RDMs). If not set or set as NULL, then order the bars by the y value.
#Return:
#gg_bar_plot: the ggplot of the bar plot.
RSA_relatedness_bar_plot=function(df,as_panel=F,axis_text_size,df_rdm_color,
                                  noise_ceiling=T,limit_y,remove_panel_title=F,bar_order=NULL){
  #Parameters----------------------------------------------
  #Set the limit to fit the size of the plot if the y_limit is not specified manually
  #Note that one might want to specify it manually when faceting the plots
  if(missing("limit_y")){
    limit_y=c(min(min(df$cand_relatedness_r_avg-df$cand_SEs),0),
              max(df$cand_relatedness_r_avg+df$cand_SEs))
  }
  n_subjects=df$n_subjects[1]
  n_models=
    df%>%
      distinct(cand_RDM_names)%>%
      nrow()
  #Plot title
  if(!as_panel){
    plot_title="How closely is the reference RDM \nrelated to each of the candidate RDMs?"
    title_size=12
  }else{
    plot_title=paste0(df$VOI_name[1],'\n',df$age_group[1])
    title_size=10
  }
  #y axis title
  if(!as_panel){
    y_axis_title=paste0("RDM correlation\n",
                        "Kendall-taua, averaged across",
                        n_subjects," subjects")
  }else{
    y_axis_title=NULL
  }
  #The order of RDMs by the y value (to enable ordering by y value when faceting)----------------------------
  # Defaults as arranging bars by the y value
  if (missing(bar_order)|is.null(bar_order)){
    df=
      df%>%
      mutate(ord=factor(rank(-cand_relatedness_r_avg,ties.method = "first")))
  }else{#If specified manually
    df=
      df%>%
      mutate(ord=factor(cand_RDM_names_axis_text,level=bar_order))
  }

  #Create data frame for the ceiling band--------------------
  
  # df_ceiling_value=
  #   df%>%
  #     distinct(ceiling_lower,ceiling_upper,
  #              age_group,VOI_name)%>%
  #   gather(y_type,y,matches("ceiling"))%>%
  #   mutate(x=)
  # 
  # df_ceiling_plot=data.frame(x=c(0,0,n_models+1,n_models+1),
  #                            y=c(df_ceiling_value$ceiling_lower,df_ceiling_value$ceiling_upper,
  #                                df_ceiling_value$ceiling_upper,df_ceiling_value$ceiling_lower))
  
  df_ceiling=data.frame(x=c(0,0,n_models+1,n_models+1),
                        y=c(df$ceiling_lower[1],df$ceiling_upper[1],
                           df$ceiling_upper[1], df$ceiling_lower[1]))
  #Set the color for the bars in the plot (in the order of "df")---------------
  bar_colors=
    df%>%
      mutate(cand_RDM_names=as.character(cand_RDM_names))%>%
      left_join(df_rdm_color%>%
                  rename(cand_RDM_names=RDM_name),
                by = "cand_RDM_names")%>%
      arrange(ord)%>% # Arrange by the order of the bars
      pull(RDM_color)
  
  #Add in asterisk signs indicating significances (FDR controled)----------
  df=
    df%>%
    mutate(cand_RDM_names_axis_text=ifelse(cand_relatedness_p<=thresh_fdr,
                                           paste0("* ",cand_RDM_names_axis_text),
                                           cand_RDM_names_axis_text))
  
  #Plot the bar plot (with ceiling band)----------------------
  gg_bar_plot=
    df%>%
      ggplot(aes(x=ord,y=cand_relatedness_r_avg))+
      # geom_col(fill="#1da8af")+
      geom_col(aes(fill=ord))+
      geom_errorbar(aes(ymin=cand_relatedness_r_avg-cand_SEs,
                        ymax=cand_relatedness_r_avg+cand_SEs),
                    width=0.3)+
      scale_fill_manual(values = bar_colors)+
      labs(x=NULL,y=y_axis_title,title=plot_title)+
      # geom_hline(yintercept=0)+
      theme_classic()+
      theme(legend.position = "none",
            axis.line.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.5,
                                       face = "bold",size=axis_text_size),
            plot.title = element_text(hjust = 0.5,size = title_size))+
      scale_y_continuous(expand = c(0,0),
                         limits = limit_y)+
      scale_x_discrete(labels=setNames(as.character(df$cand_RDM_names_axis_text),df$ord))
  
  #Add the noise ceiling
  if(noise_ceiling){
    gg_bar_plot=
      gg_bar_plot+
      geom_polygon(data=df_ceiling,aes(x=x,y=y),
                   fill="grey",alpha=0.5)
  }
  #Add title to each panel plot
  if(remove_panel_title){
    gg_bar_plot=gg_bar_plot+
      labs(title=NULL)
  }
  return(gg_bar_plot)
}


#Customized pairwise.t.test.with.t.and.df()-----------------------------
pairwise.t.test.with.t.and.df <- function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, 
                                           paired = FALSE, alternative = c("two.sided", "less", "greater"), 
                                           ...) 
{
  if (paired & pool.sd) 
    stop("pooling of SD is incompatible with paired tests")
  DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(g)))
  g <- factor(g)
  p.adjust.method <- match.arg(p.adjust.method)
  alternative <- match.arg(alternative)
  if (pool.sd) {
    METHOD <- "t tests with pooled SD"
    xbar <- tapply(x, g, mean, na.rm = TRUE)
    s <- tapply(x, g, sd, na.rm = TRUE)
    n <- tapply(!is.na(x), g, sum)
    degf <- n - 1
    total.degf <- sum(degf)
    pooled.sd <- sqrt(sum(s^2 * degf)/total.degf)
    compare.levels <- function(i, j) {
      dif <- xbar[i] - xbar[j]
      se.dif <- pooled.sd * sqrt(1/n[i] + 1/n[j])
      t.val <- dif/se.dif
      if (alternative == "two.sided") 
        2 * pt(-abs(t.val), total.degf)
      else pt(t.val, total.degf, lower.tail = (alternative == 
                                                 "less"))
    }
    compare.levels.t <- function(i, j) {
      dif <- xbar[i] - xbar[j]
      se.dif <- pooled.sd * sqrt(1/n[i] + 1/n[j])
      t.val = dif/se.dif 
      t.val
    }       
  }
  else {
    METHOD <- if (paired) 
      "paired t tests"
    else "t tests with non-pooled SD"
    compare.levels <- function(i, j) {
      xi <- x[as.integer(g) == i]
      xj <- x[as.integer(g) == j]
      t.test(xi, xj, paired = paired, alternative = alternative, 
             ...)$p.value
    }
    compare.levels.t <- function(i, j) {
      xi <- x[as.integer(g) == i]
      xj <- x[as.integer(g) == j]
      t.test(xi, xj, paired = paired, alternative = alternative, 
             ...)$statistic
    }
    compare.levels.df <- function(i, j) {
      xi <- x[as.integer(g) == i]
      xj <- x[as.integer(g) == j]
      t.test(xi, xj, paired = paired, alternative = alternative, 
             ...)$parameter
    }
  }
  PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
  TVAL <- pairwise.table.t(compare.levels.t, levels(g), p.adjust.method)
  if (pool.sd) 
    DF <- total.degf
  else
    DF <- pairwise.table.t(compare.levels.df, levels(g), p.adjust.method)           
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
              p.adjust.method = p.adjust.method, t.value = TVAL, dfs = DF)
  class(ans) <- "pairwise.htest"
  ans
}
pairwise.table.t <- function (compare.levels.t, level.names, p.adjust.method) 
{
  ix <- setNames(seq_along(level.names), level.names)
  pp <- outer(ix[-1L], ix[-length(ix)], function(ivec, jvec) sapply(seq_along(ivec), 
                                                                    function(k) {
                                                                      i <- ivec[k]
                                                                      j <- jvec[k]
                                                                      if (i > j)
                                                                        compare.levels.t(i, j)               
                                                                      else NA
                                                                    }))
  pp[lower.tri(pp, TRUE)] <- pp[lower.tri(pp, TRUE)]
  pp
}